#! usr/bin/env/python

"""
Problem Title: Linguistic Complexity of a Genome

Given: A DNA string s of length at most 100 kbp.

Return: The linguistic complexity lc(s).

URL: http://rosalind.info/problems/ling/
"""

import sys
from math import log

class SuffixTree(object):
	'''Creates a suffix tree for the provided word.'''
	def __init__(self, word):
		'''Initializes the suffix tree.'''
		self.nodes = [self.Node(None,0)]
		self.edges = dict()
		if type(word) == str:
			self.addWord(word)

	class Node(object):
	    '''Suffix tree node class.'''
	    def __init__(self, parent, number):
	        self.parent = parent
	        self.number = number
	        self.children = []

	    def addChild(self, child):
	    	self.children.append(child)

	    def removeChild(self, child):
	    	self.children.remove(child)

	    def updateParent(self, parent):
	    	self.parent = parent


	def addWord(self, word):
		'''Add a word to the suffix tree.'''
		# Check to make sure word ends in '$'.
		if word[-1] != '$':
			word += '$'
		self.word = word
		self.n = len(self.word)

		for i in xrange(self.n):
			parent_node, edge_start, overlap = self.insertPosition(i,self.nodes[0])

			if overlap:
				p_edge_start, p_edge_end = self.edges[(parent_node.parent.number, parent_node.number)]
				
				# Get the edge to insert
				insert_len = 0
				while word[edge_start:edge_start+insert_len] == word[p_edge_start:p_edge_start+insert_len]:
					insert_len += 1

				# Create a new node for insertion
				new_node = self.Node(parent_node.parent,len(self.nodes))
				new_node.addChild(parent_node)
				self.addNode(parent_node.parent, p_edge_start, p_edge_start + insert_len-1, new_node)

				# Update the parent node since a new node is inserted above it
				del self.edges[(parent_node.parent.number, parent_node.number)]
				parent_node.parent.removeChild(parent_node)
				parent_node.updateParent(new_node)
				self.edges[(parent_node.parent.number, parent_node.number)] = [p_edge_start + insert_len-1, p_edge_end]
				
				# Add new child node
				self.addNode(new_node, edge_start + insert_len-1, self.n)

			else:
				# No insertion necessary, just append the new node.
				self.addNode(parent_node, edge_start, self.n)

	def insertPosition(self, start_index, parent_node):
		'''Determine the location and method to insert a suffix into the suffix tree.'''
		for child_node in parent_node.children:
			edge_start, edge_end = self.edges[(parent_node.number,child_node.number)]
			if self.word[start_index:start_index+edge_end-edge_start] == self.word[edge_start:edge_end]:
				return self.insertPosition(start_index+edge_end-edge_start, child_node)

			elif self.word[edge_start] == self.word[start_index]:
				return child_node, start_index,  True

		return parent_node, start_index, False	

	def addNode(self, parent_node, edge_start, edge_end, child_node=None):
		'''Adds a node and the associated edge to the suffix tree.'''
		# Create child node, if necessary
		if child_node == None:
			child_node = self.Node(parent_node, len(self.nodes))
		# Add node to node list
		self.nodes.append(child_node)
		# Add child to parent
		parent_node.addChild(child_node)
		# Add edge to edge dict
		self.edges[(parent_node.number,child_node.number)] = [edge_start, edge_end]

	def printEdges(self):
		'''Returns the string representations of the edges.'''
		return [self.word[i:j] for i,j in self.edges.values()]

dataset = sys.argv[1]
with open(dataset) as input_data:
	dna = input_data.read().strip()
	n = len(dna)

# Create a Suffix Tree.
ling_suffix_tree = SuffixTree(dna)

# After removing the termination symbol $, if necessary, each edge corresponds to len(edge) substrings.
# Specifically, the substrings are generated by concatenating previous edges with the prefixes of the current edge.
edges = [edge if edge[1] != n+1 else [edge[0], n] for edge in ling_suffix_tree.edges.values()]
sub = float(sum([edge[1]-edge[0] for edge in edges]))

# The number of possible substrings of length k is min(4^k, n-k-1).
# Minimum because it depends on if there's enough room in the string to fit all of the 4^k possible substrings.
m = float(sum([n-k+1 if k > log(n+1)/log(4) else 4**k for k in range(1, n+1)])) # log's and if statement to avoid 4^k when k large.

# Print and save the answer.
print sub/m

with open('answer.txt', 'w') as outfile:
	outfile.write(str(sub/m))